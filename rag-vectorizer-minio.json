{
  "name": "RAG Vectorizer - MinIO",
  "nodes": [
    {
      "parameters": {
        "content": "## RAG Vectorizer con MinIO\nRecibe webhooks desde la app Flask para vectorizar o eliminar documentos.\n- POST /vectorize: Sube y vectoriza un nuevo documento\n- POST /delete: Elimina un documento del vector store",
        "height": 200,
        "width": 600,
        "color": 5
      },
      "id": "sticky-header",
      "name": "Info",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        200
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-vectorize",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-vectorize",
      "name": "Webhook Vectorize",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        100,
        500
      ],
      "webhookId": "rag-vectorize-webhook"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-delete",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-delete",
      "name": "Webhook Delete",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        100,
        800
      ],
      "webhookId": "rag-delete-webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "file-id",
              "name": "file_id",
              "value": "={{ $json.body.document_id }}",
              "type": "string"
            },
            {
              "id": "file-title",
              "name": "file_title",
              "value": "={{ $json.body.original_filename }}",
              "type": "string"
            },
            {
              "id": "file-type",
              "name": "file_type",
              "value": "={{ $json.body.file_type }}",
              "type": "string"
            },
            {
              "id": "minio-url",
              "name": "minio_url",
              "value": "={{ $json.body.minio_url }}",
              "type": "string"
            },
            {
              "id": "callback-url",
              "name": "callback_url",
              "value": "={{ $json.body.callback_url }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "set-file-info",
      "name": "Set File Info",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        320,
        500
      ]
    },
    {
      "parameters": {
        "url": "={{ $('Set File Info').item.json.minio_url }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "id": "download-from-minio",
      "name": "Download from MinIO",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        540,
        500
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM documents_pg WHERE metadata->>'file_id' = '{{ $('Set File Info').item.json.file_id }}'",
        "options": {}
      },
      "id": "delete-old-vectors",
      "name": "Delete Old Vectors",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        760,
        500
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM document_rows WHERE dataset_id = '{{ $('Set File Info').item.json.file_id }}'",
        "options": {}
      },
      "id": "delete-old-rows",
      "name": "Delete Old Doc Rows",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        980,
        500
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Set File Info').item.json.file_id }}",
            "title": "={{ $('Set File Info').item.json.file_title }}",
            "url": "={{ $('Set File Info').item.json.minio_url }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "url",
              "displayName": "url",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            }
          ]
        },
        "options": {}
      },
      "id": "insert-metadata",
      "name": "Insert Document Metadata",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1200,
        500
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "xlsx-check",
                    "leftValue": "={{ $('Set File Info').item.json.file_type }}",
                    "rightValue": "xlsx",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "csv-check",
                    "leftValue": "={{ $('Set File Info').item.json.file_type }}",
                    "rightValue": "csv",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "pdf-check",
                    "leftValue": "={{ $('Set File Info').item.json.file_type }}",
                    "rightValue": "pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "docx-check",
                    "leftValue": "={{ $('Set File Info').item.json.file_type }}",
                    "rightValue": "docx",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "switch-file-type",
      "name": "Switch File Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        1420,
        500
      ]
    },
    {
      "parameters": {
        "operation": "xlsx",
        "options": {}
      },
      "id": "extract-excel",
      "name": "Extract from Excel",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1700,
        300
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "extract-csv",
      "name": "Extract from CSV",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1700,
        460
      ]
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "id": "extract-pdf",
      "name": "Extract PDF Text",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1700,
        620
      ]
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "id": "extract-text",
      "name": "Extract Plain Text",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1700,
        900
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://dashboard-api.ogn8n2507.site/api/extract-docx",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "extract-docx",
      "name": "Extract DOCX Text",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1700,
        780
      ]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-excel",
      "name": "Aggregate Excel",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1920,
        300
      ]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-csv",
      "name": "Aggregate CSV",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1920,
        460
      ]
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "summarize-tabular",
      "name": "Summarize Tabular",
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1,
      "position": [
        2140,
        380
      ]
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_rows",
          "mode": "list",
          "cachedResultName": "document_rows"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "dataset_id": "={{ $('Set File Info').item.json.file_id }}",
            "row_data": "={{ $json.toJsonString().replaceAll(/'/g, \"''\") }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "dataset_id",
              "displayName": "dataset_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_data",
              "displayName": "row_data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            }
          ]
        },
        "options": {}
      },
      "id": "insert-rows-excel",
      "name": "Insert Table Rows (Excel)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1920,
        180
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_rows",
          "mode": "list",
          "cachedResultName": "document_rows"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "dataset_id": "={{ $('Set File Info').item.json.file_id }}",
            "row_data": "={{ $json.toJsonString().replaceAll(/'/g, \"''\") }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "dataset_id",
              "displayName": "dataset_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_data",
              "displayName": "row_data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            }
          ]
        },
        "options": {}
      },
      "id": "insert-rows-csv",
      "name": "Insert Table Rows (CSV)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1920,
        560
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "code": {
          "execute": {
            "code": "const { PromptTemplate } = require('@langchain/core/prompts');\n\n// Buscar contenido en m√∫ltiples campos posibles\nlet documentContent = $input.item.json?.data || $input.item.json?.text || $input.item.json?.content || $input.item.json?.body;\n\n// Si hay datos binarios, convertir a string\nif (!documentContent && $input.item.binary) {\n    const binaryKey = Object.keys($input.item.binary)[0];\n    if (binaryKey) {\n        documentContent = Buffer.from($input.item.binary[binaryKey].data, 'base64').toString('utf-8');\n    }\n}\n\nconst maxChunkSize = 1000;\nconst minChunkSize = 400;\n\nif (!documentContent) {\n    throw new Error('No document found in input. Available fields: ' + JSON.stringify(Object.keys($input.item.json || {})));\n}\n\nconst llm = await this.getInputConnectionData('ai_languageModel', 0);\n\nfunction cleanText(text) {\n    return text.replace(/\\s+/g, ' ').trim();\n}\n\n// Escapar llaves para PromptTemplate (evita error 'Single } in template')\nfunction escapeForTemplate(text) {\n    return text.replace(/\\{/g, '{{').replace(/\\}/g, '}}');\n}\n\nconst chunks = [];\nlet remainingText = cleanText(documentContent);\nlet chunkNumber = 1;\n\nif (remainingText.length <= maxChunkSize) {\n    chunks.push({\n        content: remainingText,\n        chunk: chunkNumber,\n        chunk_size: remainingText.length\n    });\n} else {\n    while (remainingText) {\n        const textToAnalyze = remainingText.substring(0, maxChunkSize);\n        const escapedText = escapeForTemplate(textToAnalyze);\n        \n        const promptText = `You are analyzing a document to find the best transition point to split it into meaningful sections.\n\nYour goal: Keep related content together and split where topics naturally transition.\n\nRead this text carefully and identify where one topic/section ends and another begins:\n\n${escapedText}\n\nFind the best transition point that occurs BEFORE character position ${maxChunkSize}.\n\nLook for:\n- Section headings or topic changes\n- Paragraph boundaries where the subject shifts\n- Complete conclusions before new ideas start\n- Natural breaks between different aspects of the content\n\nOutput the LAST WORD that appears right before your chosen split point.\nJust the single word itself, nothing else.\nExample: If you want to split after \"The company was founded in 2022.\" then output: \"2022\"`;\n        \n        const prompt = PromptTemplate.fromTemplate(promptText);\n        const chain = prompt.pipe(llm);\n        \n        let breakPoint = maxChunkSize;\n        \n        try {\n            const response = await chain.invoke();\n            const responseText = response.content || response.text || response.toString();\n            const breakWord = responseText.trim();\n            \n            if (breakWord) {\n                const wordIndex = textToAnalyze.lastIndexOf(breakWord);\n                if (wordIndex !== -1) {\n                    breakPoint = wordIndex + breakWord.length;\n                    while (breakPoint < textToAnalyze.length && \n                           (textToAnalyze[breakPoint] === '.' || \n                            textToAnalyze[breakPoint] === '!' || \n                            textToAnalyze[breakPoint] === '?' || \n                            textToAnalyze[breakPoint] === ',' || \n                            textToAnalyze[breakPoint] === ';' || \n                            textToAnalyze[breakPoint] === ':' || \n                            textToAnalyze[breakPoint] === ' ')) {\n                        breakPoint++;\n                        if (textToAnalyze[breakPoint - 1] === ' ') break;\n                    }\n                    breakPoint = Math.min(breakPoint, maxChunkSize);\n                }\n            }\n        } catch (error) {\n            console.log('LLM failed to determine breakpoint, using max size:', error.message);\n            breakPoint = maxChunkSize;\n        }\n        \n        const chunk = remainingText.substring(0, breakPoint).trim();\n        \n        if (chunk) {\n            chunks.push({\n                content: chunk,\n                chunk: chunkNumber,\n                chunk_size: chunk.length\n            });\n            chunkNumber++;\n        }\n        \n        remainingText = remainingText.substring(breakPoint).trim();\n        \n        if (!remainingText) {\n            break;\n        }\n    }\n}\n\nlet i = 0;\nwhile (i < chunks.length) {\n    if (chunks[i].chunk_size < minChunkSize) {\n        if (i + 1 < chunks.length && \n            chunks[i].chunk_size + chunks[i + 1].chunk_size <= maxChunkSize) {\n            chunks[i].content += ' ' + chunks[i + 1].content;\n            chunks[i].chunk_size = chunks[i].content.length;\n            chunks.splice(i + 1, 1);\n        } \n        else if (i > 0 && \n                 chunks[i - 1].chunk_size + chunks[i].chunk_size <= maxChunkSize) {\n            chunks[i - 1].content += ' ' + chunks[i].content;\n            chunks[i - 1].chunk_size = chunks[i - 1].content.length;\n            chunks.splice(i, 1);\n        } else {\n            i++;\n        }\n    } else {\n        i++;\n    }\n}\n\nconst returnData = chunks.map(chunk => ({\n    json: chunk\n}));\n\nreturn returnData;"
          }
        },
        "inputs": {
          "input": [
            {
              "type": "ai_languageModel",
              "maxConnections": 1,
              "required": true
            },
            {
              "type": "main",
              "required": true
            }
          ]
        },
        "outputs": {
          "output": [
            {
              "type": "main"
            }
          ]
        }
      },
      "id": "langchain-splitter",
      "name": "LangChain Text Splitter",
      "type": "@n8n/n8n-nodes-langchain.code",
      "typeVersion": 1,
      "position": [
        2360,
        620
      ]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {}
      },
      "id": "openai-model",
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2440,
        820
      ],
      "credentials": {
        "openAiApi": {
          "id": "GWAdEx62Jz5Ohm3u",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": "text-embedding-3-small",
        "options": {}
      },
      "id": "embeddings-openai",
      "name": "Embeddings OpenAI",
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1,
      "position": [
        2640,
        620
      ],
      "credentials": {
        "openAiApi": {
          "id": "GWAdEx62Jz5Ohm3u",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json.content || $json.data || $json.text || $json.concatenated_data }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $('Set File Info').first().json.file_id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $('Set File Info').first().json.file_title }}"
              }
            ]
          }
        }
      },
      "id": "data-loader",
      "name": "Default Data Loader",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        2840,
        760
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "text-splitter",
      "name": "Recursive Character Text Splitter",
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        2920,
        900
      ]
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": "documents_pg",
        "options": {}
      },
      "id": "pgvector-store",
      "name": "PGVector Store",
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        2720,
        400
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE rag_documents SET status = 'ready', updated_at = NOW() WHERE id = {{ $('Set File Info').first().json.file_id }}",
        "options": {}
      },
      "id": "update-status-ready",
      "name": "Update Status Ready",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2980,
        400
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, message: 'Document vectorized successfully', file_id: $('Set File Info').first().json.file_id }) }}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        3200,
        400
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "delete-file-id",
              "name": "file_id",
              "value": "={{ $json.body.document_id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "set-delete-info",
      "name": "Set Delete Info",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        320,
        800
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM documents_pg WHERE metadata->>'file_id' = '{{ $json.file_id }}'",
        "options": {}
      },
      "id": "delete-pgvector",
      "name": "Delete from PGVector",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        540,
        800
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM document_rows WHERE dataset_id = '{{ $('Set Delete Info').item.json.file_id }}'",
        "options": {}
      },
      "id": "delete-rows",
      "name": "Delete Rows",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        760,
        800
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM document_metadata WHERE id = '{{ $('Set Delete Info').item.json.file_id }}'",
        "options": {}
      },
      "id": "delete-metadata",
      "name": "Delete Metadata",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        980,
        800
      ],
      "credentials": {
        "postgres": {
          "id": "eIfwJYAuNOQS39Ra",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, message: 'Document deleted successfully', file_id: $('Set Delete Info').first().json.file_id }) }}",
        "options": {}
      },
      "id": "respond-delete-success",
      "name": "Respond Delete Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1200,
        800
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook Vectorize": {
      "main": [
        [
          {
            "node": "Set File Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set File Info": {
      "main": [
        [
          {
            "node": "Delete Old Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Vectors": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows": {
      "main": [
        [
          {
            "node": "Insert Document Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata": {
      "main": [
        [
          {
            "node": "Download from MinIO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download from MinIO": {
      "main": [
        [
          {
            "node": "Switch File Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch File Type": {
      "main": [
        [
          {
            "node": "Extract from Excel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from CSV",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract PDF Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract DOCX Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Plain Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Excel": {
      "main": [
        [
          {
            "node": "Aggregate Excel",
            "type": "main",
            "index": 0
          },
          {
            "node": "Insert Table Rows (Excel)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from CSV": {
      "main": [
        [
          {
            "node": "Aggregate CSV",
            "type": "main",
            "index": 0
          },
          {
            "node": "Insert Table Rows (CSV)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Excel": {
      "main": [
        [
          {
            "node": "Summarize Tabular",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate CSV": {
      "main": [
        [
          {
            "node": "Summarize Tabular",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize Tabular": {
      "main": [
        [
          {
            "node": "PGVector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract PDF Text": {
      "main": [
        [
          {
            "node": "LangChain Text Splitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Plain Text": {
      "main": [
        [
          {
            "node": "LangChain Text Splitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract DOCX Text": {
      "main": [
        [
          {
            "node": "LangChain Text Splitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "LangChain Text Splitter",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "LangChain Text Splitter": {
      "main": [
        [
          {
            "node": "PGVector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "PGVector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "PGVector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "PGVector Store": {
      "main": [
        [
          {
            "node": "Update Status Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Status Ready": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Delete": {
      "main": [
        [
          {
            "node": "Set Delete Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Delete Info": {
      "main": [
        [
          {
            "node": "Delete from PGVector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete from PGVector": {
      "main": [
        [
          {
            "node": "Delete Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Rows": {
      "main": [
        [
          {
            "node": "Delete Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Metadata": {
      "main": [
        [
          {
            "node": "Respond Delete Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "minio-v2",
  "meta": {
    "instanceId": "a76ee565d5030c7cf86590b8e4b0193690bbdbeb1bc473ece830424f5478fc5b"
  },
  "id": "rag-vectorizer-minio",
  "tags": []
}